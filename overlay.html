<!doctype html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Overlay</title>
    <style>
        html,body { margin:0; padding:20px; background:#111; color:#0f0; font-family:system-ui, sans-serif; }
        .toast { background:rgba(0,0,0,.6); color:#fff; padding:10px 14px; border-radius:10px; margin-top:12px; }
        #messages { max-width: 640px; }
        #quests { margin-top:18px; }
        .quest { background:rgba(0,0,0,.5); color:#fff; padding:8px 10px; border-radius:10px; margin-top:8px; }
        #audioGate { position:fixed; top:10px; right:10px; }
        #wsStatus { position:fixed; bottom:10px; right:10px; background:rgba(0,0,0,.5); color:#fff; padding:6px 10px; border-radius:8px; }
        #requests { margin-top:18px; }
        .request { background:rgba(0,0,0,.5); color:#fff; padding:8px 10px; border-radius:10px; margin-top:8px; }

    </style>
</head>
<body>
<h2>Overlay Connected âœ…</h2>
<button id="audioGate">Enable Sound</button>
<div id="messages"></div>
<div id="quests"><h3 style="color:#9f9;">Quest Log</h3></div>
<div id="requests"><h3 style="color:#9f9;">Requests</h3></div>
<div id="wsStatus">WS: idle</div>

<script>
    const msgs = document.getElementById("messages");
    const questList = document.getElementById("quests");
    const audioGateBtn = document.getElementById("audioGate");
    const wsStatus = document.getElementById("wsStatus");
    const cooldown = new Map();           // ability cooldowns per id
    const requestElems = new Map(); // id -> element
    const requestsList = document.getElementById("requests");
    let audioEnabled = false;

    // ---- audio gate (needed by some browsers; OBS often not needed) ----
    function enableAudio() {
        const a = new Audio("data:audio/mp3;base64,//uQZAAAAAAAAAAAAAAAAAAAA"); // tiny silent clip
        a.play().catch(()=>{}).finally(() => {
            audioEnabled = true;
            audioGateBtn.style.display = "none";
        });
    }
    audioGateBtn.addEventListener("click", enableAudio);

    // ---- helpers ----
    function toast(text) {
        if (!text) return;
        const d = document.createElement("div");
        d.className = "toast";
        d.textContent = text;
        msgs.appendChild(d);
    }

    function play(url) {
        if (!url) return beep();
        try {
            const a = new Audio(url);
            a.volume = 0.7;
            a.play().catch(()=>{});
        } catch { /* noop */ }
    }

    function beep(ms=200, freq=880) {
        try {
            const C = new (window.AudioContext||window.webkitAudioContext)();
            const o = C.createOscillator(), g = C.createGain();
            o.connect(g); g.connect(C.destination);
            o.type = "square"; o.frequency.value = freq;
            g.gain.setValueAtTime(0.2, C.currentTime);
            o.start(); o.stop(C.currentTime + ms/1000);
        } catch { /* noop */ }
    }

    // ---- browser TTS ----
    function speak(text, voiceHint) {
        if (!("speechSynthesis" in window)) { toast("TTS not supported"); return; }
        if (!text) return;
        const u = new SpeechSynthesisUtterance(text);
        if (voiceHint) {
            const voices = speechSynthesis.getVoices();
            const match = voices.find(v => v.name.toLowerCase().includes(String(voiceHint).toLowerCase()));
            if (match) u.voice = match;
        }
        u.rate = 1.0; u.pitch = 1.0; u.volume = 1.0;
        speechSynthesis.speak(u);
    }
    // warm voices list on some browsers
    if ('speechSynthesis' in window) {
        speechSynthesis.getVoices();
        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = () => {};
        }
    }

    // ---- quest rendering with progress + icon support ----
    function renderRequest(d){
        const id = d.id;
        if (!id) return;
        let el = requestElems.get(id);
        const label = `${d.board || "(request)"}${d.note ? " â€” " + d.note : ""}`;
        const phone = d.masked_phone ? ` <small style="color:#9f9">(${d.masked_phone})</small>` : "";
        const html = `ðŸ“ž ${label}${phone}`;
        if (!el) {
            el = document.createElement("div");
            el.className = "request";
            el.dataset.id = id;
            requestsList.appendChild(el);
            requestElems.set(id, el);
        }
        el.innerHTML = html;
    }
    function removeRequest(id){
        const el = requestElems.get(id);
        if (el) { el.remove(); requestElems.delete(id); }
    }

    // ---- WebSocket with auto-reconnect ----
    const wsUrl = (location.protocol === "https:" ? "wss://" : "ws://") + location.host + "/ws";
    let ws, retry = 0;

    function connectWS() {
        wsStatus.textContent = "WS: connecting";
        ws = new WebSocket(wsUrl);

        ws.onopen = () => {
            retry = 0;
            wsStatus.textContent = "WS: connected";
            toast("WebSocket open â†’ " + wsUrl);
        };

        ws.onmessage = (event) => {
            let msg; try { msg = JSON.parse(event.data); } catch { return; }
            if (!msg || !msg.type) return;

            if (msg.type === "DONATION") {
                const d = msg.data || {};
                const cents = Number(d.amount || 0);
                const dollars = isFinite(cents) ? (cents/100).toFixed(2) : "0.00";
                toast(`ðŸ’¸ ${d.donor || "Anonymous"} donated $${dollars}${d.msg ? " â€” " + d.msg : ""}`);
            }

            if (msg.type === "ABILITY_FIRE") {
                const d = msg.data || {};
                const id = d.id || "ability";
                const until = cooldown.get(id) || 0;
                const now = Date.now();
                if (now >= until) {
                    cooldown.set(id, now + 3000); // 3s per-ability cooldown
                    d.sfx_url ? play(d.sfx_url) : beep();
                }
            }

            if (msg.type === "TTS_PLAY") {
                const d = msg.data || {};
                speak(d.text, d.voice);
            }

            // New format with progress
            if (msg.type === "QUEST_UPSERT") {
                renderQuest(msg.data || {});
            }

            // Back-compat: plain add with no progress/target
            if (msg.type === "QUEST_ADD") {
                const d = msg.data || {};
                d.progress = d.progress ?? 0;
                d.target = d.target || 1;
                renderQuest(d);
            }

            if (msg.type === "QUEST_REMOVE") {
                const d = msg.data || {};
                if (d.id) removeQuest(d.id);
            }

            if (msg.type === "REQUEST_ADD") {
                renderRequest(msg.data || {});
            }

            if (msg.type === "REQUEST_REMOVE") {
                const d = msg.data || {};
                if (d.id != null) removeRequest(d.id);
            }
        };

        ws.onclose = () => {
            wsStatus.textContent = "WS: disconnected";
            const delay = Math.min(30000, 1000 * Math.pow(2, retry++)); // 1sâ†’2sâ†’4sâ€¦ up to 30s
            wsStatus.textContent = `WS: reconnecting in ${Math.round(delay/1000)}s`;
            setTimeout(connectWS, delay);
        };

        ws.onerror = () => { /* let onclose handle retry */ };
    }

    connectWS();
</script>
</body>
</html>
